<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Quote Image Generator</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif; background:#0f1724; color:#fff; margin:0; padding:20px; }
    .wrap { max-width:1200px; margin:0 auto; display:flex; gap:20px; }
    .controls { width:320px; background:#0b1220; padding:12px; border-radius:8px; box-shadow:0 6px 16px rgba(0,0,0,0.6); }
    .controls label { display:block; font-size:13px; margin-top:8px; color:#cbd5e1; }
    .controls input[type="text"], .controls textarea, .controls input[type="color"], .controls select { width:100%; padding:8px; margin-top:6px; border-radius:6px; border:1px solid #22303f; background:#07101a; color:#fff; }
    .controls textarea { height:120px; resize:vertical; font-family:inherit; }
    .controls button { margin-top:12px; width:100%; padding:10px; border-radius:8px; background:#0ea5a1; color:#062325; border:none; cursor:pointer; font-weight:600; }
    canvas { background:#111827; border-radius:8px; box-shadow:0 8px 30px rgba(2,6,23,0.6); }
    .small { font-size:12px; color:#94a3b8; margin-top:6px; }
    .row { display:flex; gap:8px; }
    .file-input { color:#94a3b8; }
    footer { color:#7c8aa5; font-size:13px; margin-top:12px; }
  </style>
</head>
<body>
  <center>
    <h1>Quote Image Generator</h1>
    <div class="wrap">
        <div class="controls">
        <label>Author
            <input id="author" type="text" value="太郎">
        </label>

        <label>Text
            <textarea id="text">こんにちは！</textarea>
        </label>

        <label>Avatar image (URL or file)
            <input id="avatarUrl" type="text" placeholder="https://..." />
            <input id="avatarFile" type="file" accept="image/*" class="file-input" />
        </label>

        <label>Background color
            <input id="bgColor" type="color" value="#1f2937" />
        </label>

        <label>Text color
            <input id="textColor" type="color" value="#ffffff" />
        </label>

        <div class="row" style="margin-top:8px">
            <label style="flex:1"><input id="colorMode" type="checkbox" checked /> Color</label>
            <label style="flex:1"><input id="negapoji" type="checkbox" /> Invert</label>
        </div>

        <div class="row">
            <button id="renderBtn">作成する</button>
            <button id="downloadBtn">画像をダウンロード</button>
        </div>

        </div>

        <div>
        <canvas id="canvas" width="800" height="400"></canvas>
        <div style="margin-top:12px; color:#9aa8c3">画像サイズ: 800×400</div>
        </div>
    </div>
    </center>

<script>
/* ---- Regexes (Pythonで使っていたものに合わせる) ---- */
const DISCORD_EMOJI_RE = /<(a?):([a-zA-Z0-9_]{1,32}):([0-9]{17,22})>/g;
const UNICODE_EMOJI_RE = /[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F700}-\u{1F77F}\u{1F780}-\u{1F7FF}\u{1F800}-\u{1F82F}\u{1F830}-\u{1F8FF}\u{1F900}-\u{1F9FF}\u{2600}-\u{27BF}\u{2B50}]+/u;
const COMBINED_EMOJI_RE = new RegExp('<a?:[a-zA-Z0-9_]{1,32}:[0-9]{17,22}>|' + UNICODE_EMOJI_RE.source, 'gu');

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });

/* Utility: load image from file or URL, returns HTMLImageElement or throws */
function loadImageFromFileOrUrl(fileInput, urlText) {
  return new Promise((resolve, reject) => {
    if (fileInput && fileInput.files && fileInput.files[0]) {
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => resolve(img);
        img.onerror = (e) => reject(e);
        img.src = reader.result;
      };
      reader.onerror = reject;
      reader.readAsDataURL(fileInput.files[0]);
    } else if (urlText && urlText.trim().length > 0) {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => resolve(img);
      img.onerror = (e) => reject(e);
      img.src = urlText;
    } else {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => resolve(img);
      img.onerror = (e) => reject(e);
      img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="400" height="400"><rect width="100%" height="100%" fill="#6b7280"/></svg>');
    }
  });
}

function drawAvatarWithFade(img) {
  const avatarW = 400, avatarH = 400;
  const x = 0, y = canvas.height - avatarH;
  const off = document.createElement('canvas');
  off.width = avatarW; off.height = avatarH;
  const octx = off.getContext('2d');
  octx.drawImage(img, 0, 0, avatarW, avatarH);
  const mask = octx.createLinearGradient(avatarW/2, 0, avatarW, 0);
  const maskCanvas = document.createElement('canvas');
  maskCanvas.width = avatarW; maskCanvas.height = avatarH;
  const mctx = maskCanvas.getContext('2d');
  mctx.fillStyle = 'black';
  mctx.fillRect(0,0,avatarW,avatarH);
  const g = mctx.createLinearGradient(avatarW/2, 0, avatarW, 0);
  g.addColorStop(0, 'rgba(0,0,0,0)');
  g.addColorStop(1, 'rgba(0,0,0,1)');
  mctx.fillStyle = 'white';
  mctx.fillRect(0,0,avatarW,avatarH);
  const grad = mctx.createLinearGradient(avatarW/2,0,avatarW,0);
  grad.addColorStop(0, 'rgba(255,255,255,1)');
  grad.addColorStop(1, 'rgba(255,255,255,0)');
  mctx.fillStyle = grad;
  mctx.fillRect(0,0,avatarW,avatarH);
  octx.globalCompositeOperation = 'destination-in';
  octx.drawImage(maskCanvas, 0, 0);
  ctx.drawImage(off, x, y);
}

function wrapTextWithScrollCut(text, fontSize, maxWidth, maxHeight, lineHeight) {
  const lines = [];
  const wordsAndChars = text.split('\n');
  ctx.font = `${fontSize}px "Segoe UI", "Noto Sans JP", sans-serif`;
  for (const rawLine of wordsAndChars) {
    let current = '';
    for (const ch of rawLine) {
      const test = current + ch;
      const w = ctx.measureText(test).width;
      if (w <= maxWidth) {
        current = test;
      } else {
        lines.push(current);
        current = ch;
        if (lines.length * lineHeight >= maxHeight - lineHeight*2) {
          let cur = current;
          const ell = '…';
          while (ctx.measureText(cur + ell).width > maxWidth) {
            if (cur.length === 0) break;
            cur = cur.slice(0, -1);
          }
          lines.push(cur + ell);
          return lines;
        }
      }
    }
    if (current.length > 0) lines.push(current);
    if (lines.length * lineHeight >= maxHeight - lineHeight*2) {
      const last = lines.pop() || '';
      let cur = last;
      const ell = '…';
      while (ctx.measureText(cur + ell).width > maxWidth) {
        if (cur.length === 0) break;
        cur = cur.slice(0, -1);
      }
      lines.push(cur + ell);
      return lines;
    }
  }
  return lines;
}

/* Helper: detect next token positions of COMBINED_EMOJI_RE */
function iterateTokens(text) {
  const re = COMBINED_EMOJI_RE;
  re.lastIndex = 0;
  let lastIndex = 0;
  let m;
  const parts = [];
  while ((m = re.exec(text)) !== null) {
    if (m.index > lastIndex) {
      parts.push({type:'text', text: text.slice(lastIndex, m.index)});
    }
    parts.push({type:'emoji', text: m[0]});
    lastIndex = re.lastIndex;
  }
  if (lastIndex < text.length) parts.push({type:'text', text: text.slice(lastIndex)});
  return parts;
}

async function loadEmojiImage(token) {
  try {
    const url = `https://emojicdn.elk.sh/${encodeURIComponent(token)}?style=apple`;
    const img = await loadImageUrl(url);
    return img;
  } catch (e) {
    return null;
  }
}

/* load an image from url with crossOrigin anonymous, with timeout */
function loadImageUrl(url, timeout = 5000) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    let done = false;
    const t = setTimeout(()=> {
      if (!done) { done = true; reject(new Error('timeout')); }
    }, timeout);
    img.onload = () => { if (!done) { done = true; clearTimeout(t); resolve(img); } };
    img.onerror = (e) => { if (!done) { done = true; clearTimeout(t); reject(e); } };
    img.src = url;
  });
}

/* Draw text with emoji mixing; returns Promise because it may fetch emoji images */
async function drawTextWithEmojis(x, y, text, fontSize, fill, maxWidth) {
  ctx.font = `${fontSize}px "Segoe UI", "Noto Sans JP", sans-serif`;
  ctx.fillStyle = fill;
  let cursorX = x;
  const parts = iterateTokens(text);
  for (const p of parts) {
    if (p.type === 'text') {
      ctx.fillText(p.text, cursorX, y);
      cursorX += ctx.measureText(p.text).width;
    } else {
      const token = p.text;
      let emojiImg = null;
      try {
        emojiImg = await loadEmojiImage(token);
      } catch {}
      if (emojiImg) {
        const emojiSize = Math.round(fontSize * 0.95);
        const dy = y - fontSize;
        ctx.drawImage(emojiImg, cursorX, dy + (fontSize - emojiSize)/2, emojiSize, emojiSize);
        cursorX += ctx.measureText('M').width;
      } else {
        ctx.fillText(token, cursorX, y);
        cursorX += ctx.measureText(token).width;
      }
    }
    if (maxWidth && cursorX - x > maxWidth) break;
  }
}

async function createQuoteImage(options) {
  const width = canvas.width, height = canvas.height;
  ctx.fillStyle = options.background;
  ctx.fillRect(0,0,width,height);

  drawAvatarWithFade(options.avatarImg);

  const baseFontSize = 30;
  const nameFontSize = 20;

  const textX = 420;
  const maxTextWidth = width - textX - 50;
  const maxTextHeight = height - 80;
  const lineHeight = baseFontSize + 10;

  ctx.font = `${baseFontSize}px "Segoe UI", "Noto Sans JP", sans-serif`;
  const lines = wrapTextWithScrollCut(options.text, baseFontSize, maxTextWidth, maxTextHeight, lineHeight);

  const textBlockHeight = lines.length * lineHeight;
  const textYStart = Math.round((height - textBlockHeight) / 2) + baseFontSize;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const approx = line.replace(/<(a?:[a-zA-Z0-9_]{1,32}:[0-9]{17,22})>/g, 'あ');
    const bboxWidth = ctx.measureText(approx).width;
    const lineX = Math.round((width + textX - 50 - bboxWidth) / 2);
    await drawTextWithEmojis(lineX, textYStart + i * lineHeight, line, baseFontSize, options.textcolor, maxTextWidth);
  }

  ctx.font = `${nameFontSize}px "Segoe UI", "Noto Sans JP", sans-serif`;
  const authorText = `- ${options.author}`;
  const authorW = ctx.measureText(authorText).width;
  const authorX = Math.round((width + textX - 50 - authorW) / 2);
  const authorY = textYStart + lines.length * lineHeight + 10 + nameFontSize/2;
  ctx.fillStyle = options.textcolor;
  ctx.fillText(authorText, authorX, authorY);

  ctx.font = `${nameFontSize}px "Segoe UI", "Noto Sans JP", sans-serif`;
  ctx.fillText(options.fake ? "FakeQuote - SharkBot" : "SharkBot", options.fake ? 580 : 700, 20 + nameFontSize/2);

  if (options.negapoji) {
    try {
      const imageData = ctx.getImageData(0,0,width,height);
      const d = imageData.data;
      for (let i=0;i<d.length;i+=4) {
        d[i] = 255 - d[i];
        d[i+1] = 255 - d[i+1];
        d[i+2] = 255 - d[i+2];
      }
      ctx.putImageData(imageData,0,0);
    } catch (e) {
      console.warn('Invert failed (CORS?)', e);
    }
  }

  if (!options.colorBool) {
    try {
      const imageData = ctx.getImageData(0,0,width,height);
      const d = imageData.data;
      for (let i=0;i<d.length;i+=4) {
        const v = Math.round(0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2]);
        d[i]=d[i+1]=d[i+2]=v;
      }
      ctx.putImageData(imageData,0,0);
    } catch (e) {
      console.warn('Grayscale failed (CORS?)', e);
    }
  }
}

document.getElementById('renderBtn').addEventListener('click', async () => {
  const author = document.getElementById('author').value || 'Unknown';
  const text = document.getElementById('text').value || '';
  const bg = document.getElementById('bgColor').value;
  const textcolor = document.getElementById('textColor').value;
  const colorMode = document.getElementById('colorMode').checked;
  const negapoji = document.getElementById('negapoji').checked;
  const fake = false;
  const avatarUrl = document.getElementById('avatarUrl').value;
  const avatarFile = document.getElementById('avatarFile');

  document.getElementById('renderBtn').textContent = 'Rendering...';
  document.getElementById('renderBtn').disabled = true;

  let avatarImg;
  try {
    avatarImg = await loadImageFromFileOrUrl(avatarFile, avatarUrl);
  } catch (e) {
    console.warn('avatar load failed, using placeholder', e);
    avatarImg = await loadImageUrl('data:image/svg+xml;charset=utf-8,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="400" height="400"><rect width="100%" height="100%" fill="#6b7280"/></svg>'));
  }

  try {
    await createQuoteImage({
      author, text, avatarImg, background: bg, textcolor, colorBool: colorMode, negapoji, fake
    });
  } catch (e) {
    console.error(e);
    alert('Rendering failed: ' + e.message);
  } finally {
    document.getElementById('renderBtn').textContent = 'Render';
    document.getElementById('renderBtn').disabled = false;
  }
});

document.getElementById('downloadBtn').addEventListener('click', () => {
  const dataUrl = canvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = dataUrl;
  a.download = 'quote.png';
  a.click();
});
</script>
</body>
</html>